def h(curve, P, Q, X):
    """ Returns (p, q) for function h_{P,Q}(X) = p/q, as in Miller's algorithm for n-th Weil pairing. """
    if P.x is None or Q.x is None:
        # Special case for O, since h_{O,·}(X) = h_{·,O}(X) has no divisors.
        return curve.field.from_coefficients(1), curve.field.from_coefficients(1)
    lmbd = curve.slope(P, Q)
    if lmbd is not None:    # lmbd != infty
        p = (X.y - P.y - lmbd * (X.x - P.x))
        q = (X.x + P.x + Q.x - lmbd ** 2)
    else:
        p = X.x - P.x
        q = curve.field.from_coefficients(1)
    return p, q


def f(curve, P, X, n):
    """ Returns function f_P(X), as in Miller's algorithm for n-th Weil pairing. """
    T = P
    # Encoding "f = p1^x1 * p2^x2 / q1^y1 * q2^y2" with f_terms = {p1: x1, p2: x2, q1: -y1, q2: -y2}
    f_terms = {}
    for epsilon in bin(n)[3:]:    # Skip 0b prefix
        # Compute f = f^2 * h_{T,T}
        p, q = h(curve, T, T, X)
        f_terms = {factor: 2*ex for factor, ex in f_terms.items()}  # f = f^2
        f_terms[p] = f_terms.get(p, 0) + 1                          # f = f * h_{T,T}
        f_terms[q] = f_terms.get(q, 0) - 1
        # Double T
        T = T + T
        if epsilon == '1':
            # Compute f = f * h_{T,P}
            p, q = h(curve, T, P, X)
            f_terms[p] = f_terms.get(p, 0) + 1  # f = f * h_{T,T}
            f_terms[q] = f_terms.get(q, 0) - 1
            # Add T to P
            T = T + P
    # Remove 0-factors, ensuring their total multiplicity is 0.
    assert f_terms.pop(curve.field.from_coefficients(0), 0) == 0
    # Compute f(X)
    f_eval = curve.field.from_coefficients(1)
    for factor, ex in f_terms.items():
        f_eval = f_eval * (curve.field.from_coefficients(factor) ** ex)
    return f_eval


def weil_pairing(P, Q, n, S=None):
    """ Computes Weil pairing with n-th root unities. """

    # Sanity checks
    curve = P.curve
    if P.curve != Q.curve or (S is not None and P.curve != S.curve):
        raise ValueError('All points must belong to the same curve.')
    if n * P != curve.neutral_element():
        raise ValueError(f'{P=} is not in the n-torsion subgroup of E(n) (order(P) does not divide {n})')
    if n * Q != curve.neutral_element():
        raise ValueError(f'{Q=} is not in the n-torsion subgroup of E(n) (order(Q) does not divide {n})')

    # Find a suitable S point not in <P, Q>
    if S is None:
        for S in curve.point_generator():
            if n * S != curve.neutral_element():
                # S's order does not divide n, implying S is not in <P, Q>.
                break
    if S is None:   # still None
        raise ValueError('No suitable S point found -> subgroup generated by P and Q is the whole group.')
    terms = [
         f(curve, P=P, X=Q+S, n=n),
         f(curve, P=P, X=S, n=n),
         f(curve, P=Q, X=P-S, n=n),
         f(curve, P=Q, X=-S, n=n)
    ]
    result = (terms[0]/terms[1]) / (terms[2]/terms[3])
    if result ** n != 1:
        raise ValueError(f'Unexpected result: e_{n}({P}, {Q}; {S=}) = {result}, but ({result})^{n} = {result ** n} != 1')
    return result
